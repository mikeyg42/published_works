// frontend/src/hex-maze/assets/js/hex-grid/index.d.ts

/// <reference types="three" />
import * as TweenJS from '@tweenjs/tween.js';

declare global {
  interface Window {
    vg: VG;
    TWEEN: typeof TweenJS;
  }
}

export interface VG {
  // Core constants
  VERSION: string;
  PI: number;
  TAU: number;
  DEG_TO_RAD: number;
  RAD_TO_DEG: number;
  SQRT3: number;

  // Constants for object types
  TILE: string;
  HEX: string;

  // Constructors – callable with new
  Scene: new (sceneConfig: any, controlConfig: any) => VGScene;
  HexGrid: new (config?: any) => VGHexGrid;
  Board: new (grid: VGHexGrid, finderConfig?: any) => VGBoard;
  Cell: new (q?: number, r?: number, s?: number, h?: number) => VGCell;
  Tile: new (config: VGTileConfig) => VGTile;
  LinkedList: VGLinkedListConstructor;
  PathAnimator: new (config?: any) => VGPathAnimator;
  Signal: new () => VGSignal;
  
  Tools: VGTools;

  // Loader for asynchronous texture loading
  Loader: {
    renderer?: THREE.WebGLRenderer | THREE.WebGPURenderer;
    init(crossOrigin?: boolean, renderer?: THREE.WebGLRenderer | THREE.WebGPURenderer): void;
    loadTexture(
      url: string,
      mapping: THREE.Mapping,
      onLoad: (texture: THREE.Texture) => void,
      onError?: (error: any) => void
    ): THREE.Texture;
  };
}

// The following interfaces represent the instance side of your classes:

export interface VGScene {
  renderer: THREE.WebGLRenderer | THREE.WebGPURenderer;
  usingWebGPU: boolean;
  width: number;
  height: number;
  camera: THREE.Camera;
  container: THREE.Scene;
  orthoZoom: number;
  attachTo(element: HTMLElement): void;
  add(mesh: THREE.Object3D): void;
  remove(mesh: THREE.Object3D): void;
  render(): void;
  updateOrthoZoom(): void;
  focusOn(obj: THREE.Object3D): void;
  updateSize(width: number, height: number): void;
}

export interface VGHexGrid {
  type: string;
  size: number;
  cellSize: number;
  cells: { [hash: string]: VGCell };
  numCells: number;
  extrudeSettings: any;
  autogenerated: boolean;
  cellShape: THREE.Shape;
  cellGeo: THREE.BufferedGeometry;
  cellShapeGeo: THREE.ShapeGeometry;
  cellToPixel(cell: VGCell): THREE.Vector3;
  pixelToCell(pos: THREE.Vector3): VGCell;
  getCellAt(pos: THREE.Vector3): VGCell;
  getNeighbors(cell: VGCell, diagonal: boolean, filter?: (a: VGCell, b: VGCell) => boolean): VGCell[];
  getRandomCell(): VGCell;
  cellToHash(cell: VGCell): string;
  distance(cellA: VGCell, cellB: VGCell): number;
  clearPath(): void;
  traverse(cb: (cell: VGCell) => void): void;
  generateTile(cell: VGCell, scale: number, material: THREE.Material): VGTile;
  generateTiles(config?: any): VGTile[];
  generateTilePoly(material?: THREE.Material): THREE.Mesh;
  generate(config?: any): void;
  generateOverlay(size: number, overlayObj: THREE.Object3D, overlayMat: THREE.Material): void;
  add(cell: VGCell): VGCell;
  remove(cell: VGCell): void;
  dispose(): void;
  _cubeRound(h: VGCell): VGCell;
}

export interface VGBoard {
  tiles: VGTile[];
  tileGroup: THREE.Object3D;
  group: THREE.Object3D;
  grid: VGHexGrid;
  overlay: THREE.Object3D | null;
  finder: any;
  setEntityOnTile(entity: any, tile: VGTile): void;
  addTile(tile: VGTile): void;
  removeTile(tile: VGTile): void;
  removeAllTiles(): void;
  getTileAtCell(cell: VGCell): VGTile | null;
  snapToGrid(pos: THREE.Vector3): void;
  snapTileToGrid(tile: VGTile): VGTile;
  getRandomTile(): VGTile;
  findPath(startTile: VGTile, endTile: VGTile, heuristic?: any): VGCell[];
  setGrid(newGrid: VGHexGrid): void;
  generateOverlay(size: number): void;
  generateTilemap(config?: any): void;
  reset(): void;
}

export interface VGCell {
  q: number;
  r: number;
  s: number;
  h: number;
  tile: VGTile | null;
  userData: any;
  walkable: boolean;
  _calcCost: number;
  _priority: number;
  _visited: boolean;
  _parent: VGCell | null;
  uniqueID: string;
  randomId?: string;
  set(q: number, r: number, s: number): this;
  copy(cell: VGCell): this;
  add(cell: VGCell): this;
  equals(cell: VGCell): boolean;
}

export interface VGTileConfig {
  cell: VGCell;
  geometry: THREE.BufferedGeometry;
  material?: THREE.Material;
  scale?: number;
}

export interface VGTile {
  cell: VGCell;
  uniqueID: string;
  geometry: THREE.BufferedGeometry;
  material: THREE.Material;
  objectType: string;
  entity: any;
  userData: any;
  selected: boolean;
  highlight: number;
  mesh: THREE.Mesh;
  position: THREE.Vector3;
  rotation: THREE.Euler;
  _emissive: number | null;
  select(): this;
  deselect(): this;
  toggle(): this;
  dispose(): void;
  pulseLight(scene: THREE.Scene, options?: any): void;
}

export interface VGPathAnimator {
  duration: number;
  easing: any;
  pathColor: number;
  pathHeight: number;
  pathThickness: number;
  highlightDuration: number;
  maxIntensity: number;
  signal: VGSignal;
  tweenGroup: any;
  AnimatePath(path: VGCell[] | VGLinkedList, options?: any): any;
  Update(time: number): void;
  Dispose(): void;
}

export interface VGSignal {
  add(listener: (...args: any[]) => any, listenerContext?: any, priority?: number): VGSignalBinding;
  addOnce(listener: (...args: any[]) => any, listenerContext?: any, priority?: number): VGSignalBinding;
  remove(listener: (...args: any[]) => any, context?: any): Function;
  removeAll(context?: any): void;
  getNumListeners(): number;
  halt(): void;
  dispatch(...params: any[]): void;
  forget(): void;
  dispose(): void;
  toString(): string;
}

export interface VGSignalBinding {
  active: boolean;
  isOnce: boolean;
  context: any;
  execute(paramsArr: any[]): any;
  detach(): any;
  isBound(): boolean;
  toString(): string;
}

// VGLinkedList – instance side
export interface VGLinkedList {
  first: any;
  last: any;
  length: number;
  add(obj: any): void;
  has(obj: any): boolean;
  moveUp(obj: any): void;
  moveDown(obj: any): void;
  sort(compare: (a: any, b: any) => number): void;
  remove(obj: any): boolean;
  shift(): any;
  pop(): any;
  concat(list: VGLinkedList): void;
  clear(): void;
  dispose(): void;
  dump(msg: string): void;
}

// VGLinkedListConstructor – static side
export interface VGLinkedListConstructor {
  new (): VGLinkedList;
  generateID(): string;
}

export interface VGTools {
  merge(target: any, src: any): any;
  clamp(val: number, min: number, max: number): number;
  random(min: number, max?: number): number;
  randomInt(min: number, max?: number): number;
  generateID(): string;
  sign(val: number): number;
  normalize(v: number, min: number, max: number): number;
  getShortRotation(angle: number): number;
  now(): number;
  empty(node: Node): void;
  radixSort(arr: number[], idxBegin?: number, idxEnd?: number, bit?: number): void;
  randomizeRGB(base: string, range: number): string;
  getJSON(config: { url: string; callback: (json: any) => void; cache?: boolean; scope?: any }): void;
  PI: number;
  TAU: number;
}

export {};

export default vg;
